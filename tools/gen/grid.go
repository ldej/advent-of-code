package main

import (
	"flag"
	"os"
	"text/template"
)

type data struct {
	Type string
	Name string
}

// Example: go run tools/gen/grid.go -name=Rune -type=rune > 2020/rune_grid.go
func main() {
	var d data
	flag.StringVar(&d.Type, "type", "", "The subtype used for the grid being generated")
	flag.StringVar(&d.Name, "name", "", "The name used for the grid being generated. This should start with a capital letter so that it is exported.")
	flag.Parse()

	t := template.Must(template.New("grid").Parse(gridTemplate))
	t.Execute(os.Stdout, d)
}

var gridTemplate = `// GENERATED BY github.com/ldej/advent-of-code/tools/gen/grid.go DO NOT EDIT MANUALLY
package tools

import (
	"fmt"
	"log"

	"github.com/ldej/advent-of-code/tools"
)

type {{.Name}}Grid [][]{{.Type}}

func New{{.Name}}Grid(x, y int) {{.Name}}Grid {
	var newGrid = make({{.Name}}Grid, x)
	for i := 0; i < x; i++ {
		newGrid[i] = make([]{{.Type}}, y)
	}
	return newGrid
}

type {{.Name}}Window struct {
	Grid    {{.Name}}Grid
	X    int
	Y    int
	// CenterX and CenterY are the location of the center in the square
	// in case the window is for an odd sized square
	CenterX int
	CenterY int
}

type {{.Name}}Cell struct {
	Value {{.Type}}
	X     int
	Y     int
}

func (g {{.Name}}Grid) Print() {
	for _, line := range g {
		fmt.Println(line)
	}
	fmt.Println()
}

func (g {{.Name}}Grid) At(rowIndex, columnIndex int) {{.Type}} {
	return g[rowIndex][columnIndex]
}

func (g {{.Name}}Grid) Set(rowIndex, columnIndex int, value {{.Type}}) {
	g[rowIndex][columnIndex] = value
}

func (g {{.Name}}Grid) Count(val {{.Type}}) int {
	count := 0
	for cell := range g.Cells() {
		if cell.Value == val {
			count += 1
		}
	}
	return count
}

func (g {{.Name}}Grid) OutOfBounds(x, y int) bool {
	return x < 0 || y < 0 || x >= len(g) || y >= len(g[0])
}

func (g {{.Name}}Grid) Copy() {{.Name}}Grid {
	cp := make({{.Name}}Grid, len(g))
	for i := range g {
		cp[i] = make([]{{.Type}}, len(g[i]))
		copy(cp[i], g[i])
	}
	return cp
}

func (g {{.Name}}Grid) Cells() chan {{.Name}}Cell {
	ch := make(chan {{.Name}}Cell)

	go func() {
		for i := 0; i < len(g); i++ {
			for j := 0; j < len(g[0]); j++ {
				ch <- {{.Name}}Cell{
					Value: g[i][j],
					X:     j,
					Y:     i,
				}
			}
		}
		close(ch)
	}()
	return ch
}

// Window returns a window of the grid with a certain height and width
// The x and y are the top left corner of the window
// In case the window height and width are equal and odd, the x and y are the center of the window
func (g {{.Name}}Grid) Window(windowHeight int, windowWidth int, x, y int) {{.Name}}Window {
	if windowHeight == 1 && windowWidth == 1 {
		log.Fatal("use Cells for 1x1 windows")
	}
	oddSquare := windowHeight == windowWidth && windowHeight&1 == 1 && windowWidth&1 == 1

	window := make({{.Name}}Grid, 0)

	subtract := 0
	if oddSquare {
		subtract = (windowWidth - 1) / 2
	}

	for i := tools.Max(x-subtract, 0); i < tools.Min(x+windowHeight-subtract, len(g)); i++ {
		min, max := tools.Max(y-subtract, 0), tools.Min(y+windowWidth-subtract, len(g[0]))
		window = append(window, g[i][min:max])
	}

	var centerX, centerY int

	if oddSquare {
		centerX = (windowHeight - 1) / 2
		if x-centerX < 0 {
			centerX = centerX - x
		}
		if x == 0 {
			centerX = 0
		}
		centerY = (windowWidth - 1) / 2
		if y-centerY < 0 {
			centerY = centerY - y
		}
		if y == 0 {
			centerY = 0
		}
	}
	return {{.Name}}Window{
		Grid:    window,
		X:       x,
		Y:       y,
		CenterX: centerX,
		CenterY: centerY,
	}
}

func (g {{.Name}}Grid) Windows(windowHeight int, windowWidth int) chan {{.Name}}Window {
	ch := make(chan {{.Name}}Window)

	go func() {
		for i := 0; i <= len(g)-windowHeight; i++ {
			for j := 0; j <= len(g[0])-windowWidth; j++ {
				ch <- g.Window(windowHeight, windowWidth, i, j)
			}
		}
		close(ch)
	}()
	return ch
}

func (g {{.Name}}Grid) TopEdge() []{{.Type}} {
	return g[0]
}

func (g {{.Name}}Grid) RightEdge() []{{.Type}} {
	return g.Column(len(g[0]) - 1)
}

func (g {{.Name}}Grid) BottomEdge() []{{.Type}} {
	return g[len(g)-1]
}

func (g {{.Name}}Grid) LeftEdge() []{{.Type}} {
	return g.Column(0)
}

func (g {{.Name}}Grid) Edges() [][]{{.Type}} {
	return [][]{{.Type}}{g.TopEdge(), g.RightEdge(), g.BottomEdge(), g.LeftEdge()}
}

func (g {{.Name}}Grid) WithoutEdges() {{.Name}}Grid {
	var newGrid {{.Name}}Grid
	for i := 1; i < len(g)-1; i++ {
		newGrid = append(newGrid, g[i][1:len(g[i])-1])
	}
	return newGrid
}

func (g {{.Name}}Grid) Column(index int) []{{.Type}} {
	var column []{{.Type}}
	for i := 0; i < len(g); i++ {
		column = append(column, g[i][index])
	}
	return column
}

// GrowAll grows in all directions in one run
func (g {{.Name}}Grid) GrowAll(defaultValue {{.Type}}) {{.Name}}Grid {
	var newGrid = make({{.Name}}Grid, len(g), len(g))
	copy(newGrid, g)
	width := len(g[0])

	emptyRow := make([]{{.Type}}, width, width)
	for i, _ := range emptyRow {
		emptyRow[i] = defaultValue
	}

	newGrid = append(append({{.Name}}Grid{emptyRow}, newGrid...), emptyRow)

	for i, row := range newGrid {
		newGrid[i] = append([]{{.Type}}{defaultValue}, row...)
	}

	for i, row := range newGrid {
		newGrid[i] = append(row, defaultValue)
	}
	return newGrid
}

// GrowUp copies the grid and adds a row to the top
func (g {{.Name}}Grid) GrowUp(defaultValue {{.Type}}) {{.Name}}Grid {
	var newGrid = make({{.Name}}Grid, len(g), len(g))
	copy(newGrid, g)
	width := len(g[0])

	emptyRow := make([]{{.Type}}, width, width)
	for i, _ := range emptyRow {
		emptyRow[i] = defaultValue
	}

	newGrid = append([][]{{.Type}}{emptyRow}, g...)
	return newGrid
}

// GrowDown copies the grid and adds a row to the bottom
func (g {{.Name}}Grid) GrowDown(defaultValue {{.Type}}) {{.Name}}Grid {
	var newGrid = make({{.Name}}Grid, len(g), len(g))
	copy(newGrid, g)

	width := len(g[0])

	emptyRow := make([]{{.Type}}, width, width)
	for i, _ := range emptyRow {
		emptyRow[i] = defaultValue
	}

	newGrid = append(newGrid, emptyRow)
	return newGrid
}

// GrowLeft copies the grid and adds a column to the left
func (g {{.Name}}Grid) GrowLeft(defaultValue {{.Type}}) {{.Name}}Grid {
	var newGrid = make({{.Name}}Grid, len(g), len(g))
	copy(newGrid, g)

	for i, row := range newGrid {
		newGrid[i] = append([]{{.Type}}{defaultValue}, row...)
	}
	return newGrid
}

// GrowRight copies the grid and adds a column to the right
func (g {{.Name}}Grid) GrowRight(defaultValue {{.Type}}) {{.Name}}Grid {
	var newGrid = make({{.Name}}Grid, len(g), len(g))
	copy(newGrid, g)

	for i, row := range newGrid {
		newGrid[i] = append(row, defaultValue)
	}
	return newGrid
}

// Grow functions that use pointers

func (g *{{.Name}}Grid) PGrow(defaultValue {{.Type}}) *{{.Name}}Grid {
	return g.PGrowUp(defaultValue).PGrowDown(defaultValue).PGrowLeft(defaultValue).PGrowRight(defaultValue)
}

func (g *{{.Name}}Grid) PGrowUp(defaultValue {{.Type}}) *{{.Name}}Grid {
	width := len((*g)[0])

	emptyRow := make([]{{.Type}}, width, width)
	for i, _ := range emptyRow {
		emptyRow[i] = defaultValue
	}

	*g = append([][]{{.Type}}{emptyRow}, *g...)
	return g
}

func (g *{{.Name}}Grid) PGrowDown(defaultValue {{.Type}}) *{{.Name}}Grid {
	width := len((*g)[0])

	emptyRow := make([]{{.Type}}, width, width)
	for i, _ := range emptyRow {
		emptyRow[i] = defaultValue
	}

	*g = append(*g, emptyRow)
	return g
}

func (g *{{.Name}}Grid) PGrowLeft(defaultValue {{.Type}}) *{{.Name}}Grid {
	for i, row := range *g {
		(*g)[i] = append([]{{.Type}}{defaultValue}, row...)
	}
	return g
}

func (g *{{.Name}}Grid) PGrowRight(defaultValue {{.Type}}) *{{.Name}}Grid {
	for i, row := range *g {
		(*g)[i] = append(row, defaultValue)
	}
	return g
}

func (g {{.Name}}Grid) Transpose() {{.Name}}Grid {
	var newGrid = make({{.Name}}Grid, 0)

	var height = len(g)
	var width = len(g[0])

	for i := 0; i < width; i++ {
		var row []{{.Type}}
		for j := 0; j < height; j++ {
			row = append(row, g[j][i])
		}
		newGrid = append(newGrid, row)
	}

	return newGrid
}

// Rotate in a clockwise direction
func (g {{.Name}}Grid) Rotate(degrees int) {{.Name}}Grid {
	switch degrees {
	case 90, -270:
		return g.Transpose().FlipHorizontal()
	case -90, 270:
		return g.Transpose().FlipVertical()
	case 180, -180:
		return g.FlipHorizontal().FlipVertical()
	case 0, 360:
		return g
	default:
		panic("Unsupported degrees")
	}
}

// Orientations returns all orientations of the grid, that is all 4 rotations and their mirrored versions
func (g {{.Name}}Grid) Orientations() []{{.Name}}Grid {
	var rotations = make([]{{.Name}}Grid, 8)

	for i := 0; i < 4; i++ {
		rotations[i] = g.Rotate(90 * i)
	}
	var flipped = g.FlipVertical()
	for i := 0; i < 4; i++ {
		rotations[4+i] = flipped.Rotate(90 * i)
	}
	return rotations
}

func (g {{.Name}}Grid) FlipVertical() {{.Name}}Grid {
	var newGrid = make({{.Name}}Grid, 0)

	for i := len(g) - 1; i >= 0; i-- {
		newGrid = append(newGrid, g[i])
	}

	return newGrid
}

func (g {{.Name}}Grid) FlipHorizontal() {{.Name}}Grid {
	var newGrid = make({{.Name}}Grid, 0)

	for i := 0; i < len(g); i++ {
		var row []{{.Type}}
		for j := len(g[0]) - 1; j >= 0; j-- {
			row = append(row, g[i][j])
		}
		newGrid = append(newGrid, row)
	}
	return newGrid
}
`
